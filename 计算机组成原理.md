# 1. 计算机系统概论

****

## 1.1 计算机系统简介

****

###   1.1.1 计算机软硬件概念

****

  计算机系统由**硬件**和**软件**两大部分组成：

* 硬件：是指计算机的实体部分，它由看得见摸得着的各种电子元器件，各类光、电、机设备的实物组成，如主机、外部设备等。

* 软件：由人们事先编制的具有各类特殊功能的程序组成，通常存放在计算机的主存或辅存内。

  **计算机性能的好坏取决于软、硬件功能的总和。**

  计算机的软件通常又可以分为两大类：系统软件和应用软件：

* 系统软件又称为系统程序，主要用来管理整个计算机系统，监视服务，使系统资源得到合理调度，高效运行。它包括：标准程序库、语言处理程序、操作系统、服务程序、数据库管理系统、网络软件等。
* 应用软件又称为应用程序，它是用户根据任务需要所编制的各种程序，如科学计算程序、数据处理程序、过程控制程序、事务管理程序等。

****

### 1.1.2 计算机的层次

****

  现代计算机具有多级层次的结构：

![](图片1\计算机层次结构.png)

  从计算机系统的多级层次结构来看，可以将硬件研究的主要对象归结为传统机器 $M_1$，和微程序机器 $M_0$。软件的研究对象主要是操作系统级以上的各级虚拟机。

****

### 1.1.3计算机组成和计算机体系结构

****

计算机体系结构：指那些能够被程序员所见到的计算机系统的属性，即概念性的结构与功能特性。

计算机组成：指如何实现计算机体系结构所体现的属性，它包含了许多对程序员来说是透明的硬件细节。

例：对于一个计算机来说，其具有乘法计算、除法计算等功能，这是其结构的组成部分，而对于乘法计算指令和除法计算指令实现的方式，则是计算机组成的问题。

****

## 1.2 计算机的基本组成

****

### 1.2.1 冯·诺伊曼计算机的特点

****

  `1945` 年，数学家冯·诺依曼（von Neumann）在研究 $\text{EDVAC}$ 机时提出了**存储程序**的概念。以此概念为基础的各类计算机通称为冯·诺依曼机。它的特点可归结如下：

* 计算机由运算器、存储器、控制器、输入设备和输出设备五大部件组成。
* 指令和数据以同等地位存放于存储器内，并可按地址寻访。 
* 指令和数据均用二进制数表示。
* 指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。
* 指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序。
* 机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成。

****

### 1.2.2 计算机的硬件框图

****

  典型的冯·诺依曼计算机是以运算器为中心的：

![](图片1\计算机硬件框图1.png)

  现代的计算机已转化为以存储器为中心：

![](图片1\计算机硬件框图2.png)

  图中各部件的功能如下：

* 运算器：完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内。
* 存储器：存放数据和程序。·控制器用来控制、指挥程序和数据的输入、运行以及处理运算结果。
* 输入设备：将人们熟悉的信息形式转换为机器能识别的信息形式，常见的有键盘、鼠标等。
* 输出设备：将机器运算结果转换为人们熟悉的信息形式，如打印机输出、显示器输出等。

  由于运算器和控制器在逻辑关系和电路结构上联系十分紧密，通常将它们合起来统称为中央处理器（Central Processing Unit,CPU）。把输入设备与输出设备简称为 `I/O` 设备（Input/Output Equipment）这样，现代计算机可认为由三大部分组成：`CPU`，`I/O`设备及主存储器（Main Memory,MM）；`CPU` 与主存储器合起来又可称为主机，`I/O` 设备又可称为外部设备。

![](图片1\计算机硬件框图3.png)

  算术逻辑单元（Arithmetic Logic Unit,ALU）：简称算逻部件，用来完成算术逻辑运算。

  控制单元（Control Unit,CU）：用来解释存储器中的指令，并发出各种操作命令来执行指令。

  `ALU` 和 `CU` 是 `CPU` 的核心部件。`I/O` 设备也受 `CU` 控制，用来完成相应的输入、输出操作。

****

### 1.2.3 计算机的工作步骤

****

  在许多科学技术的实际问题中，往往会遇到许多复杂的数学方程组，而数字计算机通常只能执行加、减、乘、除四则运算，这就要求在上机解题前，先由人工完成一些必要的准备工作。

  这些工作大致可归纳为:

* 建立数学模型：找到一系列反映研究对象变化规律的数学方程组。
* 确定计算方法：针对数学模型对应有计算机可行的计算方法。
* 编制解题程序：编写相应的计算程序使可以通过计算机运行得到结果。

  具体到计算机硬件部分：

* 主存储器存储计算程序及计算所需和产生的所有数据；
* 运算器读取主存储器的数据进行计算，并将中间结果存入主存储器；
* 控制器对这些指令进行分析来控制存储和运算的操作；
* `I/O` 设备最终将这些结果输出。

****

## 1.3 计算机硬件的主要技术指标

****

  衡量一台计算机性能的优劣是根据多项技术指标综合确定的。其中，既包含硬件的各种性能指标，又包括软件的各种功能。这里主要讨论硬件的技术指标。

****

### 1.3.1 机器字长

****

  机器字长是指 `CPU` 一次能处理数据的位数，通常与 `CPU` 的寄存器位数有关。字长越长，数的表示范围越大，精度也越高。机器的字长也会影响机器的运算速度。若 `CPU` 字长较短，又要运算位数较多的数据，那么需要经过两次或多次的运算才能完成，这样势必影响机器的运算速度。

  机器字长对硬件的造价也有较大的影响。它将直接影响加法器（或ALU)、数据总线以及存储字长的位数。所以机器字长的确定不能单从精度和数的表示范围来考虑。

****

### 1.3.2 存储容量

****

  存储器的容量应该包括主存容量和辅存容量。

  主存容量是指主存中存放二进制代码的总位数。即：$\text{存储容量二存储单元个数} \times \text{存储字长}$。

  现代计算机中常以字节数来描述容量的大小，因一个字节已被定义为 `8` 位二进制代码，故用字节数便能反映主存容量。辅存容量通常用字节数来表示。

****

### 1.3.3 运算速度

****

  计算机的运算速度与许多因素有关，如机器的主频、执行什么样的操作、主存本身的速度等都有关。

  早期用完成一次加法或乘法所需的时间来衡量运算速度，即普通法，显然是很不合理的。后来采用吉普森（Gibson）法，它综合考虑每条指令的执行时间以及它们在全部操作中所占的百分比，即：
$$
T_{\text{M}} = \sum^{n}_{i = 1}{f_i t_i}
$$
  其中，$T_{\text{M}}$ 为机器运行速度；$f_i$ 为第 $i$ 种指令占全部操作的百分比数；$t_i$ 为第 $i$ 种指令的执行时间。

  现在机器的运算速度普遍采用单位时间内执行指令的平均条数来衡量，并用 `MIPS`（Million Instruction Per Second,百万条指令每秒）作为计量单位。例如，某机每秒能执行 `200` 万条指令，则记作 `2 MIPS`。也可以用 `CPI`（Cycle Per Instruction）即执行一条指令所需的时钟周期（机器主频的倒数），或用 `FLOPS`（Floating Point Operation Per Second,浮点运算次数每秒）来衡量运算速度。

****

# 2. 计算机的发展及应用

****

## 2.1 计算机发展史

****

 早期电子计算机作为军事计算工具，但经历半个世纪飞速发展，给人类社会带来了巨大贡献。

****

### 2.1.1 计算机硬件发展

****

  早期计算机体积大，常用于工业：

* 1946 -1957：第一代电子管计算机——数据处理机。
* 1958 -1964：第二代晶体管计算机——工业控制机。

 之后硬件技术飞速发展，开始出现小型机：

* 1965 -1971：第三代中小规模集成电路计算机——小型计算机。
* 1972 -1990：大规模和超大规模集成电路计算机——微型计算机，分为：多板机（多个印刷板）、单板机、单片机（一个芯片）。
* 1991 - 至今：巨大规模集成电路计算机——单片机

****

### 2.1.2 计算机软件发展

****

  早期的计算机操作需要使用机器语言，为了更方便的操作计算机，语言进行了如下发展：

* 1950 年后：出现符号语言和汇编语言，以及将其翻译为机器语言的汇编程序。
* 1954：第一阶段代表语言 `FORTRAN` 问世，增强了程序可读性，仍面向科学和工程计算。
* 1968：第二阶段结构化程序设计阶段，`PASCAL` 语言问世，它定义了一个真正的标准语言。同时伴随着这些语言的出现，相应语言的编译程序也飞速出现。
* 至今：第三阶段面向对象程序设计阶段，代表语言是 `C++`，`Java` 等。

​    随着各种语言的出现，汇编程序、编译程序、解释程序的产生，逐渐形成了软件系统：

* 系统程序：各种服务性程序、语言程序、操作系统、数据库管理系统。
* 应用程序：用户利用计算机来解决某些问题二编制的程序。

****

## 2.2 计算机的应用

****

  近年来计算机技术和通信技术相互融合，使计算机的应用范围从科学计算、数据处理等传统领域扩展到办公自动化、多媒体、电子商务、虚拟工厂、远程教育等，遍及社会、政治、经济、军事、科技以及个人文化生活和家庭生活的各个角落：

* 科学计算和数据处理：科研领域，计算机是不可或缺的存在。
* 工业控制和实时控制：工业生产的自动化，智能制造等。
* 虚拟现实：模拟真实的场景，覆盖科研、生产、生活等领域。
* 信息管理与大数据：提供各种管理程序的平台、对大数据的处理和数据分析。
* 人工智能：新兴技术，未来学科，期望巨大，前景高。

****

# 3. 系统总线

****

  在第一章中，我们分别了解了构成计算机的硬件，若要使得计算机正常工作，必须通过线路将各个器件进行连接，连接方式不同，对计算机工作的影响也不同。

****

## 3.1 总线的基本概念

****

 ### 3.1.1 总线的定义

****

  计算机系统的五大部件之间的互连方式有两种：

* 分散连接：各部件之间使用单独的连线，以运算器为中心；
* 总线连接：将各部件连到一组公共信息传输线上，以以存储器为中心。

  早期的计算机大多数用分散连接方式，其内部连线十分复杂，当 `I/O` 设备与存储器交换信息时，都需经过运算器，致使运算器停止运算，严重影响了 `CPU` 的工作效率。

  由此我们引出**总线的定义**：

* 连接各个部件的信息传输线，是各个部件共享的传输介质；
* 构成计算机系统的互联机构，是多个系统功能部件之间进行数据传送的公共通路。

  采用总线连接可以极大优化分散连接带来的一些列问题：

![](图片3\总线连接.png)

  `CPU` 与主存之间再开辟一条总线，称为存储总线。这组总线速度高，仅供主存与 `CPU` 之间传输信息。这样既提高了传输效率，又减轻了系统总线的负担，还保留了 `I/O` 设备与存储器交换信息时不经过 `CPU` 的特点。**现代计算机大多数采用各类总线结构**。

****

### 3.1.2 总线的分类

****

#### 片内总线

****

  片内总线：指芯片内部的总线，如在CPU芯片内部，寄存器与寄存器之间、寄存器与算逻单元 `ALU` 之间都由片内总线连接。

****

#### 系统总线

****

  系统总线：指 `CPU`、主存、`I/O` 设备各大部件之间的信息传输线。

  按系统总线传输信息的不同分为：

* 数据总线：传输各功能部件之间的数据信息。**双向**传输，其位数与机器字长、存储字长有关。
* 地址总线：指出数据总线上的源数据或目的数据在主存单元的地址或 `I/O` 设备的地址。**单向**传输，其位数与存储单元的个数有关。
* 控制总线：发出各种控制信号的传输线。**对控制线而言，单向传输。对于控制总线总体来说，双向传输。**此外，控制总线还起到监视各部件状态的作用。对 `CPU` 而言，控制信号既有输出，又有输入。

****

#### 通信总线

****

  通信总线：用于计算机系统之间或者计算机系统与其他系统之间的通信。

  按照传输方式分为：

* 串行通信总线：数据在单条 `1` 位宽的传输线上，一位一位地按顺序分时传送，适用远距离（数千公里）的数据传输。
* 并行通信总线：数据在多条并行 `1` 位宽的传输线上，同时由源传送到目的地，适用近距离（小于 `30m`）的数据传输。

****

## 3.2 总线特性及性能指标

****

### 3.2.1 总线特性

****

总线的特性可分为：

- 机械特性：总线的物理连接方式（根数、插头、插座形状，引脚排列方式）。
- 电气特性：每根线上信号的传递方向及有效电平范围。
- 功能特性：每根线的功能（地址、数据、控制）。
- 时间特性：规定了每根总线在什么时间有效（时序关系）。

****

### 3.2.2 总线性能指标

****

  总线性能指标如下：

* 总线宽度：指数据总线的根数，用 $\text{bit}$（位）表示，多少位就是多少根线。
* 总线带宽：总线的数据传输速率，即单位时间内总线上传输数据的位数，通常用每秒传输信息的字节数来衡量：
  * 单位 $\text{MBps}$（兆字节每秒）表示。
  * 计算方法：总线工作频率（$\text{MHz}$）$\times$ 总线宽度（$\text{B}$）。
  * 例如：总线工作频率为 $33\text{ MHz}$，总线宽度为 $32$ 位（$32 \text{ bit}=4\text{ B}$），则总线带宽为 $33 \times (32 \div 8 ) = 132 \text{ MBps}$。
* 时钟同步/异步：总线上的数据与时钟同步工作的总线称为同步总线，与时钟不同步工作的总线称为异步总线。
* 总线复用：一条信号线上分时传送两种信号，如：地址线和数据线复用。
* 信号线数：地址总线、数据总线和控制总线三种总线数的总和。
* 总线控制方式：包括突发工作、自动配置、仲裁方式、逻辑方式、计数方式等。
* 其他指标：负载能力、电源电压、总线宽度能否扩展等。

****

### 3.2.3 总线标准

****

  总线标准：可视为系统与各模块、模块与模块之间的一个互连的标准界面。 其优点如下：

* 简化系统设计；
* 简化系统结构，提高系统可靠性；
* 便于系统的扩充和更新。

  此外，为了使不同厂家生产的相同功能部件可以互换使用，就需要进行系统总线的**标准化**工作。

  目前流行的总线标准有如下几种：

* `ISA` 总线：由 `IBM` 推出，又称AT总线，它使用独立于 `CPU` 的总线时钟，因此 `CPU` 可以采用比总线频率更高的时钟，有利于 `CPU` 性能的提高。
* `EISA` 总线：基于 `ISA` 扩充开放的总线标准，与 `ISA` 可以完全兼容，从 `CPU` 中分离出了总线控制权，是一种具有智能化的总线，能支持多个总线主控器和突发方式（总线上可进行成块的数据传送）的传输。
* `VESA`总线：由 `VESA` 提出的局部总线标准，又称为 `VL-BUS`（Local BUS）总线。通过局部总线控制器，将高速 `I/O` 设备直接挂在 `CPU` 上，实现 `CPU` 与高速 `I/O` 设备之间的高速数据交换。
* `PCI` 总线：由 `Intel` 公司推出，具有高性能，高兼容性，高扩展性，支持多主设备，即插即用等特点。
* `ACP` 总线：由 `Intel` 公司推出，显示卡专用的局部总线，采用点对点通道方式，以主存作为帧缓冲器，实现了高速存取。
* `RS-232C` 总线：由美国电子工业协会 `EIA` 推荐的一种串行通信总线标准。
* `USB` 总线：由 `Compaq`、`DEC`、`IBM`、`Intel`、`Microsoft`、`NEC` 和 `Northern Telecom` 等七大公司于 `1994` 年 `11` 月联合开发的计算机串行接口总线标准。具有真正的即插即用、通用连接、高速传输、标准统一等特点。

****

## 3.3 总线结构

****

### 3.3.1 单总线结构

****

![](图片3\单总线.png)

  如图是单总线结构的示意，这种结构简单，也便于扩充，但**所有的传送都通过这组共享总线**，因此极易形成计算机系统的瓶颈。它也**不允许两个以上的部件在同一时刻向总线传输信息**，这就必然会影响系统工作效率的提高。

****

### 3.3.2 多总线结构

****

#### 双总线结构

****

![](图片3\双总线1.png)

  双总线结构的特点是将速度较低的 `I/O` 设备从单总线上分离出来，形成主存总线与 `I/O` 总线分开的结构。图中通道是一个具有特殊功能的处理器，`CPU` 将一部分功能下放给通道，使其对 `I/O` 设备具有统一管理的功能，以完成外部设备与主存储器之间的数据传送，其系统的吞吐能力可以相当大。这种结构大多用于大、中型计算机系统。

****

#### 三总线结构

****

![](图片3\三总线.png)

  在三总线结构中，任一时刻只能使用一种总线。主存总线与 `DMA` 总线不能同时对主存进行存取，`I/O` 总线只有在 `CPU` 执行 `I/O` 指令时才能用到。以下另一种三总线结构的示意图：

![](图片3\三总线2.png)

****

#### 扩展总线结构

****

为了进一步提高 `I/O` 设备的性能，使其更快地响应命令，又出现了四总线结构。

![](图片3\扩展总线.png)

****

## 3.4 总线控制

****

### 3.4.1 总线判优控制

****

  众多部件共享总线，在争夺总线使用权时，应**按各部件的优先等级来解决**。

  总线判优控制分为：

* 集中式：将控制逻辑集中在一处（如在CPU中）
* 分布式：将控制逻辑分散在与总线连接的各个部件或设备上。

  常见的集中控制优先权仲裁方式有以下三种：

* **链式查询**：只需很少几根线就能按一定优先次序实现总线控制，并且很容易扩充设备，但对电路故障很敏感，且优先级别低的设备可能很难获得请求。
* **计数器定时查询**：不如链式查询方式敏感，但增加了控制线（设备地址）数，控也较复杂。
* **独立请求方式**：电响应速度快，优先次序控制灵活（通过程序改变），但控制线数量多，总线控制更复杂。

****

### 3.4.2 总线通信控制

****

  众多部件共享总线，在通信时间上，则应**按分时方式来处理**。

  即以获得总线使用权的先后顺序分时占用总线，即哪一个部件获得使用权，此刻就由它传送，下一部件获得使用权，接着下一时刻传送。这样一个接一个轮流交替传送。

  通常将完成一次总线操作的时间称为**总线周期**，分为：

* 申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定下一传输周期的总线使用权授于某一申请者。
* 寻址阶段：取得了使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块。
* 传数阶段：主模块和从模块进行数据交换，数据由源模块发出，经数据总线流入目的模块。
* 结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权。

  总线通信控制主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调如何配合。通常用四种方式：同步通信、异步通信、半同步通信和分离式通信。

****

#### 同步通信

****

  **通信双方由统一时标控制数据传送称为同步通信**。

  时标通常由CPU的总线控制部件发出，送到总线上的所有部件；也可以由每个部件各自的时序发生器发出，但必须由总线控制部件发出的时钟信号对它们进行同步。

* 优点：规定明确、统一，模块间的配合简单一致。
* 缺点：主、从模块时间配合属于强制性“同步”，必须在限定时间内完成规定的要求。并且对所有从模块都用同一限时，这就势必造成，对各不相同速度的部件而言，必须按最慢速度的部件来设计公共时钟，严重影响总线的工作效率。

在同步通信的总线系统中，总线传输周期越短，数据线的位数越多，直接影响总线的数据传输率。

****

#### 异步通信

****

  异步通信克服了同步通信的缺点，**允许各模块速度的不一致性**，给设计者充分的灵活性和选择余地。

  它没有公共的时钟标准，不要求所有部件严格的统一操作时间，而是采用**应答方式**（又称握手方式)，即当主模块发出请求（Request）信号时，一直等待从模块反馈回来“响应”（Acknowledge）信号后，才开始通信。当然，这就要求主、从模块之间增加两条应答线（握手交互信号线Handshaking)。

  异步通信有以下应答方式：

* 不互锁：
  * 主模块发出请求信号后，不必等待接到从模块的回答信号，而是经过一段时间，确认从模块已收到请求信号后，便撤销其请求信号；
  * 从模块接到请求信号后，在条件允许时发出回答信号，并且经过一段时间（这段时间的设置对不同设备而言是不同的）确认主模块已收到回答信号后，自动撤销回答信号。
* 半互锁：
  * 主模块发出请求信号，必须待接到从模块的回答信号后再撤销其请求信号，有互锁关系；
  * 从模块在接到请求信号后发出回答信号，但不必等待获知主模块的请求信号已经撤销，而是隔一段时间后自动撤销其回答信号，无互锁关系。
* 全互锁：
  * 主模块发出请求信号，必须待从模块回答后再撤销其请求信号；
  * 从模块发出回答信号，必须,待获知主模块请求信号已撤销后，再撤销其回答信号。

![](图片3\应答方式.png)

  异步串行通信的数据传送速率用**波特率**来衡量。

  波特率是指单位时间内传送二进制数据的位数，单位用 `bps` （位/秒）表示，记作波特。

****

#### 半同步通信

****

  **半同步通信既保留了同步通信的基本特点，又像异步通信那样，允许不同速度的模块和谐地工作**。

  为此增设了一条“等待”（WAIT）响应信号线，采用插人时钟（等待）周期的措施来协调通信双方的配合问题。

* 优点：其控制方式比异步通信简单，在全系统内各模块又在统一的系统时钟控制下同步工作，可靠性较高，同步结构较方便。
* 缺点：对系统时钟频率不能要求太高，故从整体上来看，系统工作的速度还不是很高。

  半同步通信适用于系统工作速度不高但又包含了由许多工作速度差异较大的各类设备组成的简单系统。

****

#### 分离式通信

****

  以上三种通信方式都是从主模块发出地址和读写命令开始，直到数据传输结束。**在整个传输周期中，系统总线的使用权完全由占有使用权的主模块和由它选中的从模块占据**。除了申请总线这一阶段外，其余时间主要花费在如下方面：

* ①主模块通过传输总线向从模块发送地址和命令。
* ②从模块按照命令进行读数据的必要准备。
* ③从模块经数据总线向主模块提供数据。

  由 ② 可见，对系统总线而言，**从模块内部读数据过程并无实质性的信息传输，总线纯属空闲等待**。

  由此提出了**分离式**的思想：

* 首先，将一个传输周期（或总线周期）分解为两个子周期。
* 第一个子周期中：
  * 主模块 $A$ 在获得总线使用权后将信息经总线传输后，由有关的从模块 $B$ 接收。
  * 主模块 $A$ 向系统总线发布这些信息后**立即放弃总线使用权**，以便其他模块使用。
* 第二个子周期中：
  * 当 $B$ 模块收到 $A$ 模块发送的命令信号，经过内部处理后，将 $A$ 模块所需的数据准备好，便由 $B$ 模块申请总线使用权.
  * 一旦获准，$B$ 模块便将 $A$ 模块所需数据发送送到总线上，供 A模块接收。
* 显然地，上述两个传输子周期都只有单方向的信息流，每个模块都变成了主模块。

  这种通信方式的**特点**如下：

* 各模块欲占用总线使用权都必须提出申请。
* 在得到总线使用权后，主模块在限定的时间内向对方传送信息，采用同步方式传送，不再等待对方的回答信号。
* 各模块在准备数据的过程中都不占用总线，使总线可接受其他模块的请求。
* 总线被占用时都在做有效工作，或者通过它发送命令，或者通过它传送数据，不存在空闲等待时间，充分地利用了总线的有效占用。

**这种方式控制比较复杂，一般在普通微型计算机系统很少采用**。

****

# 4. 存储器

****

## 4.1 概述

****

### 4.1.1 存储器分类

****

#### 按存储介质分类

****

* 半导体存储器：存储元件由半导体器件组成的存储器。
* 磁表面存储器：在金属或塑料基体的表面上添加磁性材料涂层作为记录介质。
* 磁芯存储器：由硬磁材料做成的环状元件，在磁芯中穿有驱动线（通电流）和读出线。
* 光盘存储器：光盘存储器是应用激光在记录介质（磁光材料）上进行读/写的存储器。

****

#### 按存取方式分类

****

* 随机存储器（Random Access Memory,RAM）：
  * `RAM` 是一种可读/写存储器，其任何一个存储单元的内容都可以随机存取。
* 只读存储器（Read Only Memory,ROM）：
  * `ROM` 只能对其存储的内容读出，而不能对其重新写入的存储器。
* 串行访问存储器：
  * 对存储单元进行读/写操作时，需按其物理位置的先后顺序寻找地址的存储器。
  * 主要有两种：顺序存取存储器、直接存取存储器。

****

#### 按在计算机中的作用分类

****

![](图片4\分类.png)

****

### 4.1.2 存储器的层次结构

****

#### 存储器三个主要特性的关系

****

存储器有 `3` 个主要性能指标：

* 速度
* 容量
* 每位价格（简称位价）

****

其特性关系如图所示：

![](图片4\金字塔.png)

****

#### 缓存-主存层次和主存-辅存层次

****

存储系统层次结构主要体现在缓存——主存和主存——辅存这两个存储层次上：

* `CPU` 和缓存、主存都能直接交换信息；
* 缓存能直接和 `CPU`、主存交换信息；
* 主存可以和 `CPU`、缓存、辅存交换信息。

![](图片4\存储层次.png)

****

## 4.2 主存储器 

****

### 4.2.1 概述

****

#### 主存的基本组成

****

![](图片4\主存的基本组成.png)

- 存储体：

  * 由许多**存储单元**组成；
  * 每个存储单元又包含若干个**存储元件**。
- 存储单元：

  * **以 $8$ 位二进制作为一个存储单元，也就是一个字节**。
  * 一个存储单元可以存储一串二进制代码，称这串二进制代码为一个存储字，代码位数位存储字长。
  * 存储单元的编号称为存储单元的地址号。存储单元按地址寻访。这些地址都是二进制的形式。
- MAR：
  *  存储器地址寄存器。
  *  保存了存储单元的地址（编号）。
  *  其位数反映存储单元的个数。
- MDR：
  *  存储器数据寄存器。
  *  存放存储器中从存储某单元读出、或要写入某存储单元的数据（代码）。
  *  其位数反映存储字长。


****

#### 主存的技术指标

****

* 存储容量：

  * 用能存放二进制代码的总位数表示：$\text{ 存储容量 } = \text{ 存储单元个数 } \times \text{ 存储字长 }$。
  * 用字节总数来表示：$\text{ 存储容量 } = \text{ 存储单元个数 } \times \text{ 存储字长 } \div 8$。

* 存储速度：

  * 由**存取时间**和**存取周期**来表示。

  * 存取时间/访问时间（Memory Access Time）：

    * 启动一次存储器操作（读或写）到完成该操作所需的全部时间。

    * 读出时间：从存储器接收到有效地址开始，到产生有效输出所需的全部时间。
    * 写入时间：从存储器接收到有效地址开始，到数据写入被选中单元为止所需的全部时间。

  * 存取周期（Memory Cycle Time）：

    *  存储器进行连续两次独立的存储器操作（如连续两次读操作）所需的最小间隔时间。
    * 通常存取周期大于存取时间。

* 存储器带宽：

  * 单位时间内存储器存取的信息量，单位可用字/秒或字节/秒或位/秒表示。
  * **带宽是衡量数据传输率的重要技术指标**。
  * 存储器的带宽决定了以存储器为中心的机器获得信息的传输速度，提升带宽方法如下：
    * 缩短存取周期。
    * 增加存储字长，使每个存取周期可读/写更多的二进制位数。
    * 增加存储体。

****

### 4.2.2 半导体存储芯片简介

****

#### 半导体存储芯片的基本结构

****

![](图片4\存储芯片的基本结构.png)

- 地址线：单向输入，其位数与芯片的容量有关。
- 数据线：双向传输，其位数与芯片可读出或写入的数据位数有关，也与芯片的容量有关。
- 读/写控制线：控制芯片读写操作，`WE` 为写控制信号，`OE` 为读控制信号，都是低电平有效。
- 片选线：有 `CS`和 `CE` 两种，分别为芯片选择器和芯片使能器。

**地址线和数据线共同来反应存储芯片的容量**，比如地址线 $10$ 根，数据线 $4$ 根，芯片容量为 $2^{10} \times 4 = 4 K$位。

![](图片4\存储器.png)

如上图所示，是一个由 $32$ 片 $16 K \times 1$ 位的存储芯片组成的 $64 K \times 8$ 位的存储器，每次读出一个存储字时，通过片选线选中 $8$ 片。

****

#### 半导体存储芯片的译码驱动方式

****

****

**线选法**：

![](图片4\线选法.png)

* 用一根字选择线（字线)，直接选中一个存储单元的各位（如一个字节）。
* 例如，当地址线 $A_3 A_2 A_1 A_0$ 为 $1111$ 时，则第 $15$ 根字线被选中。
* 结构较简单，但只适于容量不大的存储芯片。

**重合法**：

![](图片4\重合法.png)

* 用 $64$ 根选择线（$X$、$Y$ 两个方向各 $32$  根），便可选择 $32 \times 32$ 矩阵中的任一位。
* 例如，当地址线为全 $0$ 时，译码输出 $X_0$ 和 $Y_0$ 有效，矩阵中第 $0$ 行、第 $0$ 列共同选中的那位即被选中。
* 由于被选单元是由 $X$、$Y$ 两个方向的地址决定的，故称为重合法。

****

### 4.2.3 随机存取存储器

****

#### 静态 RAM（Static RAM, SRAM）

****

![](图片4\静态RAM.png)

**特点**：

* $T_1 \sim T_4$ 是一个由 `MOS` 管组成的触发器基本电路，由 $T_1 \sim T_6$ 这 $6$ 个 `MOS`管共同构成一个基本单元电路。
* 静态 `RAM` 是用触发器工作原理存储信息，因此即使信息读出后，它仍保持其原状态，不需要再生。
* 电源掉电时，原存信息丢失，故它属易失性半导体存储器。

**读周期**：

![](图片4\静态RAM读.jpg)

**写周期**：

![](图片4\静态RAM写.png)

****

#### 动态 RAM（Dynamic RAM,DRAM）

****

![](图片4\动态RAM.png)

**特点**：

* 靠电容存储电荷的原理来寄存信息。若电容上存有足够多的电荷表示存“1”，电容上无电荷表示存“0”。
* 即使电源不掉电，信息也会自动消失。为此，必须在 `2ms` 内对其所有存储单元恢复一次原状态，这个过程称为再生或刷新。
* 与静态 `RAM` 相比，具有集成度更高、功耗更低等特点。

**读周期**：

![](图片4\动态RAM读.png)

**写周期**：

![](图片4\动态RAM写.png)

**刷新方式**：

* 集中刷新：在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。
* 分散刷新：对每行存储单元的刷新分散到每个存取周期内完成。
* 异步刷新：前两种方式的结合，它既可缩短“死时间”，又充分利用最大刷新间隔为 `2ms` 的特点。（最佳刷新方式）

****

#### 静态 RAM 和动态 RAM 比较

****

目前，动态 `RAM` 的应用比静态 `RAM` 要广泛得多。其原因如下：

* 动态 `RAM` 的集成度远高于静态 `RAM`。
* 动态 `RAM` 行、列地址按先后顺序输送，减少了芯片引脚，封装尺寸也减少。
* 动态 `RAM` 的功耗比静态 `RAM` 小。
* 动态 `RAM` 的价格比静态 `RAM` 的价格便宜。

随着动态 `RAM` 容量不断扩大，速度不断提高，它被**广泛应用于计算机的主存**。

动态 `RAM` 的缺点：

* 由于使用动态元件（电容），因此它的速度比静态 `RAM` 低。
* 动态 `RAM` 需要再生，故需配置再生电路，也需要消耗一部分功率。
* 通常，**容量不大的高速缓冲存储器大多用静态RAM实现**。

****

### 4.2.4 只读存储器

****

#### 掩模 ROM

****

![](图片4\掩模MOS.png)

**特点**：

* 用行、列交叉处是否有耦合元件 `MOS` 管，便可区分原存“1”还是存“0”。
* 此 `ROM` 制成后不可能改变原行、列交叉处的 `MOS` 管，故用户无法改变原始状态。

****

#### PROM

****

![](图片4\PROM.png)

**特点**：

* 熔丝断和未断可区别其所存信息是“1”或“0”。
* 用户使用前，可按需要将信息存入行、列交叉的耦合元件内。若欲存“0”，则置耦合元件一大电流，将熔丝熔断。
* 已断的熔丝是无法再恢复的，故这种 `ROM` 往往只能实现一次编程，不得再修改。

****

#### EPROM

****

![](图片4\EPROM.png)

**特点**：

* 是一种可擦除可编程只读存储器。它可以由用户对其所存信息作任意次的改写。
* 依靠浮动栅的控制是否导通，进而表示“0”和“1”。
* 擦写操作可以利用紫外线照射或电气方法，另有可局部擦写的 `EEPROM`。

****

### 4.2.5 存储器与 CPU 的连接

****

#### 存储容量扩展

****

##### 位扩展

****

位扩展是指增加存储字长，例如，$2$ 片 $1K \times 4$ 位的芯片可组成 $1K \times 8$ 位的存储器：

![](图片4\位扩展.png)

****

##### 字扩展

****

字扩展是指增加存储器字的数量。例如，用 $2$ 片  $1K \times 8$ 位的存储芯片可组成一个 $2K \times 8$ 位的存储器：

![](图片4\字扩展.png)

**注意**：

* 将 $A_{10}$。用做片选信号：
  * 当 $A_{10}$ 为低电平时， $\overline{CS_0}$有效，选中左边的 $1K \times 8$ 位芯片；
  * 当 $A_{10}$ 为高电平时，反相后 $\overline{CS_0}$ 有效，选中右边的 $1K \times 8$ 位芯片。

****

##### 字、位扩展

****

字、位扩展是指既增加存储字的数量，又增加存储字长。例如，用 $8$ 片 $1K \times 4$ 位的芯片组成 $4K \times 8$ 位的存储器。

![](图片4\位字扩展.png)

****

#### 存储器与 CPU 的连接

****

##### 地址线的连接

****

存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。

* 通常总是将CPU地址线的低位与存储芯片的地址线相连。
* CPU地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。

例如，设CPU地址线为 $16$ 位 $A_{15} \sim A_0 $：

* 用 $1K \times 4$位的存储芯片时，有 $10$ 根地址线 $A_9 \sim A_0$，此时，可将CPU的低位地址 $A_9 \sim A_0$ 与存储芯片地址线 $A_9 \sim A_0$相连。
* 用 $16K \times 1$ 位存储芯片时，有 $14$ 根地址线 $A_{13} \sim A_0$，此时，可将CPU的低位地址 $A_{13} \sim A_0$ 与存储芯片地址线 $A_{13} \sim A_0$ 相连。

****

##### 数据线的连接

****

同样，CPU的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。

****

##### 读/写命令线的连接

****

CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。有些CPU的读/写命令线是分开的，此时CPU的读命令线应与存储芯片的允许读控制端相连，而CPU的写命令线则应与存储芯片的允许写控制端相连。

****

##### 片选线的连接

****

**片选线的连接是CPU与存储芯片正确工作的关键。**

存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端 $\overline{CS}$ 是否能接收到来自CPU的片选有效信号。

* 片选有效信号与CPU的访存控制信号 $\overline{MREQ}$ (低电平有效)有关，因为只有当CPU要求访存时，才需选择存储芯片。若CPU访问 I/O，则 $\overline{MREQ}$ 为高电平，表示不要求存储器工作。
* 此外，片选有效信号还和地址有关，因为CPU的地址线往往多于存储芯片的地址线，故那些未与存储芯片连上的高位地址必须和访存控制信号共同产生存储芯片的片选信号。

通常需用到一些逻辑电路，如译码器及其他各种门电路，来产生片选有效信号。

****

##### 合理选择存储芯片

****

合理选择存储芯片主要是指存储芯片类型(RAM或ROM)和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单方便。

****

### 4.2.6 存储器的校验

****

#### 汉明码的组成

****

汉明码具有一位纠错能力；

* 由编码纠错理论得知，任何一种编码是否具有检测能力和纠错能力，都与编码的最小距离有关。
* 所谓编码最小距离，是指在一种编码系统中，任意两组合法代码之间的最少二进制位数的差异。根据纠错理论得 $L - 1 = D + C$ 且 $D \ge C$ 即编码最小距离 $L$ 越大，则其检测错误的位数 $D$ 越大，纠正错误的位数 $C$ 也越大，且纠错能力恒小于或等于检错能力。
* 例如，当编码最小距离 $L = 3$ 时，这种编码可视为最多能检错二位，或能检错一位、纠错一位。

可见，倘若能在信息编码中增加若干位检测位，增大 $L$，显然便能提高检错和纠错能力。汉明码就是根据这一理论提出的具有一位纠错能力的编码。

设欲检测的二进制代码为 $n$ 位，为使其具有纠错能力，需增添k位检测位，组成 $n+k$ 位的代码。为了能准确对错误定位以及指出代码没错，新增添的检测位数 $k$ 应满足：$2^k \ge n + k + 1$。

$k$ 的位数确定后，便可由它们所承担的检测任务设定它们在被传送代码中的位置及它们的取值：

* 设 $n + k$ 位代码自左至右依次编为第 $1,2,3，\dots，n + k$ 位，而将 $k$ 位检测位记作 $C:(i=1,2,4, 8,\dots)$ 分别安插在 $n + k$ 位代码编号的第 $1,2,4,8，\dots，2^{k - 1}$ 位上。
* 这些检测位的位置设置是为了保证它们能分别承担 $n + k$ 位信息中不同数位所组成的“小组”的奇偶检测任务，使检测位和它所负责检测的小组中 $1$ 的个数为奇数或为偶数，具体分配如下：
  * 每个小组 $g_i$：有且仅有一位为它所独占，这一位是其他小组所没有的，即 $g_i$ 小组独占第 $2^{i - 1}$ 位 $(i=1,2,3,…)$。
  * 每两个小组 $g_i$ 和 $g_j$ 共同占有一位是其他小组没有的，即每两小组 $g_i,g_j$ 共同占有第 $2^{i - 1}+2^{j - 1}$ 位 $(i,j=1,2,…)$。
  * 每三个小组 $g_i,g_j,g_l$，共同占有第 $2^{i - 1} + 2^{j - 1} + 2^{l - 1}$ 位，是其他小组所没有的。
  * 依次类推，便可确定每组所包含的各位。
* ![](图片4\汉明码组成举例.png)

****

#### 汉明码的纠错过程

****

对传送后的汉明码形成新的检测位 $P_i,(i = 1,2,4,8,…)$，根据 $P_i$ 的状态，便可直接指出错误的位置。

$P_i$ 的状态由原检测位 $C_i$ 及其所在小组内“1”的个数确定的：

* 倘若按配偶原则配置的汉明码，其传送后形成新的检测位 $P_i$ 应为 $0$；
* 否则说明传送有错，并且还可直接指出出错的位置。

![](图片4\汉明码的纠错举例.png)

****

### 4.2.7 提高访存速度的措施

****

#### 单体多字系统

****

由于程序和数据在存储体内是**连续存放**的，因此 `CPU` 访存取出的信息也是连续的：

* 故可以在一个存取周期内，从同一地址取出 $4$ 条指令，然后再逐条将指令送至CPU执行;
* 每隔1/4存取周期，主存向CPU送一条指令，这样显然增大了存储器的带宽，提高了单体存储器的工作速度。

![](图片4\单体多字存储.png)

****

#### 多体并行系统

****

多体并行系统就是采用多体模块组成的存储器：

* 每个模块有相同的容量和存取速度；
* 各模块各自都有独立的地址寄存器(MAR)、数据寄存器(MDR)、地址译码、驱动电路和读/写电路；
* 这些模块能并行工作，又能交叉工作。

![](图片4\高位多体存储.png)

****

#### 高性能存储芯片

****

采用高性能存储芯片也是提高主存速度的措施之一：

* DRAM集成度高，价格便宜，广泛应用于主存。其发展速度很快，几乎每隔3年存储芯片的容量就翻两番。
* 为了进一步提高DRAM的性能，人们开发了许多对基本DRAM结构的增强功能，出现了SDRAM、RDRAM和CDRAM。

****

## 4.3 高速缓冲存储器

****

在多体并行存储系统中，由于I/O设备向主存请求的级别高于CPU访存，这就出现了CPU等待/0设备访存的现象，致使CPU空等一段时间，甚至可能等待几个主存周期，从而降低了 CPU的工作效率。

为了避免CPU与I/O设备争抢访存，可在CPU与主存之间加一级缓存，使得主存可将CPU要取的信息提前送至缓存，一旦主存在与I/0设备交换时，CPU可直接从缓存中读取所需信息，不必空等而影响效率。

****

### 4.3.1 Cache 概述

****

#### 主存和缓存的编址

****

缓存和主存的地址都分为两部分，其中两者的块内地址相等，块内地址的大小决定了块的大小，比如块内地址为 $4$ 位，并且编址方式为字节，则每块大小为 $16$ 字节。另外，Cache 中还存在一个标记，用于标识当前 Cache 块对应的主存块号。

![](图片4\Cache的组成.png)

****

#### 命中与命中率

****

主存和缓存按块存储，块的大小相同，若缓存共有 C 块，主存共有 M 块，已知 M 远远大于 C，CPU 在主存中申请数据：

* 如果这一块数据已经在缓存中了，则直接从缓存中调入CPU，称为命中；
* 否则需要从主存中访问数据，再调入到 CPU ，称为未命中；
* 如果命中，说明主存块和缓存块之间建立了对应关系，用**标记**记录与某缓存块建立了对应关系的**主存块号**。

Cache 的容量与块长是影响 Cache 效率的重要因素，通常用“命中率”来衡量 Cache 的效率。

**命中率**：指 CPU 要访问的信息已在 Cache 内的比率。

![](图片4\Cache的命中率.png)

****

#### 基本结构和工作原理

****

![](图片4\Cache的组成原理.png)

CPU通过地址总线发送主存块号，由于Cache和主存的块内地址编号相同，可以直接转换。主存块号先经过主存Cache地址映射变换机构判断是否命中:

- 如果命中则给出相应的Cache地址的块号，然后从Cache存储体中取数据通过数据总线送给CPU。
- 如果未命中，则查看Cache是否已满：
  - 如果未满，则通过主存块号访问主存，将数据装入Cache，Cache和主存有一条直接通路。
  - 如果已满，则经过Cache替换机构，通过替换算法，判断是否替换Cache的数据，以及和谁替换。
  - 与此同时，主存将CPU所需的数据通过数据总线直接交给CPU

**主存Cache地址映射变换机构：**
地址映射用于判断主存的数据可以存入到哪些Cache块中，变换机构用于查找某个主存块号所对应的Cache地址块号。

****

#### 读写操作

****

##### 读操作

****

![](图片4\Cache读操作.png)

****

##### 写操作

****

因为对Cache块内写入的信息，必须与被映射的主存块内的信息完全一致，故需要解决Cache和主存的一致性的问题：

- 写直达法（Write – through）：
  * 写操作时数据既写入Cache又写入主存，写操作时间就是访问主存的时间，Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现；
  * 缺点：会造成Cache和内存数据的频繁信息交换，如不停进行求和。
- 写回法（Write – back）：
  * 写操作时只把数据写入 Cache 而不写入主存，当 Cache 数据被替换出去时才写回主存；
  * 缺点：无法保证Cache和内存操作时间的一致性，在并行计算机（多个独立Cache和主存）中会出现问题。

****

#### 改进方式

****

Cache刚出现时，典型系统只有一个缓存，近年来普遍采用多个Cache：

- 增加 Cache 的级数：片载（片内）Cache，片外 Cache，采用多级Cache。
- 统一缓存和分立缓存：指令Cache和数据Cache是否独立存放，与指令执行的控制方式有关。

****

### 4.3.2 Cache——主存地址映射

****

由主存地址映射到Cache地址称为地址映射。地址映射方式很多：

* 直接映射（固定的映射关系)
* 全相联映射（灵活性大的映射关系）
* 组相联映射（上述两种映射的折中）

****

#### 直接映射

****

![](图片4\Cache直接映射.png)

CPU给出的主存地址由三部分组成：主存字块标记，Cache字块地址，字块内地址。

* 主存字块标记就是主存的分区号；
* 分区内的块号就是cache字块地址；
* 字块内地址就是字块内的偏移地址，在Cache和主存中相同，不用处理。

以第0块为例：由于cache中的第0块装的可能是主存中任意一个分区的第0块，所以需要**比较主存字块标记和cache上的标记是否相同，如果相同则说明命中。**

**特点**：

* 每个主存块只与一个缓存块相对应：
  * 映射关系式为：$i = j \mod{C}$ 或 $i = j \mod{2^C}$
  * 其中 $i$ 为缓存块号，$j$ 为主存块号，$C$ 为缓存块数。 
* 优点：
  * 实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。
* 缺点：
  * 不够灵活，缓存的存储空间得不到充分的利用。
  * 如果程序恰好要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。

****

#### 全相联映射

****

![](图片4\Cache全相联映射.png)

**特点**：

* 全相联映射允许主存中每一字块映射到Cache中的任何一块位置上：
  * 只要Cache中有空余则就可以装入；
  * 这种映射方式可以从已被占满的Cache中替换出任一旧字块。
* 优点：
  * 这种方式灵活，命中率也更高，缩小了块冲突率。
* 缺点：
  * 由于可以装入到任意的位置，所以要和Cache所有的块比较判断是否命中，比较次数多。
  * 所需的逻辑电路甚多，成本较高，实际的Cache还要采用各种措施来减少地址的比较次数。

****

#### 组相联映射

****

![](图片4\Cache组相联映射.png)

* Cache字块地址字段由 $c$ 位变为组地址字段 $q$ 位，且 $q = c - r$：
  * 其中 $2^c$ 表示Cache的总块数；
  * $2^q$ 表示Cache的分组个数；
  * $2^r$ 表示组内包含的块数。
* 主存字块标记字段由 $t$ 位变为 $s = t + r$ 位。

为了便于理解，假设 $c=5,q=4$，则 $r = c - q = 1$ 。其实际含义为：Cache共有 $2^c = 32$ 个字块，共分为 $2^q = 16$ 组，每组内包含$2^1 = 2$ 块。组内 $2$ 块的组相联映射又称为二路组相联。

**特点**：

* 组相联映射是对直接映射和全相联映射的一种折中：
  * 它把Cache分为 $Q$ 组，每组有 $R$ 块；
  * 映射关系为：$i = j \mod{Q}$，其中 $i$ 为缓存块号，$j$ 为主存块号
  * 某一主存块 $j$ 按模 $Q$ 映射到缓存的第 $i$ 组内的任一块，其中主存块第 $j$ 块只能放在特定的第 $i$ 组中。 
* 在Cache中查找时，先根据组地址（即$j \mod{Q}$）找到Cache对应的组，然后通过若干个并行的比较器（个数由每组块数决定）比较主存字块标记（即主存的分区号），只要有一个命中则命中。

****

#### 替换策略

****

当新的主存块需要调入Cache并且它的可用空间位置又被占满时，需要替换掉Cache的数据，这就产生了替换策略：

* 先进先出(First-In-First-Out,FIFO)算法：
  * 先进入Cache的数据先被替换。
  * 不需要记录各字块的使用情况，比较容易实现，开销小。
  * 但没有根据访存的局部性原理，故不能提高Cache的命中率。因为最早调入的信息可能以后还要用到，或者经常要用到，如循环程序。 
* 近期最少使用(Least Recently Used, LRU)：
  * 比较好地利用访存局部性原理，替换出近期用得最少的字块。
  * 它需要随时记录 Cache中各字块的使用情况，以便确定哪个字块是近期最少使用的字块。
  * 它实际是一种推测的方法，比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间。LRU算法的平均命中率比FIFO的高。 
* 随机法随机法：
  * 随机地确定被替换的块，比较简单，可采用一个随机数产生器产生一个随机的被替换的块。
  * 但它也没有根据访存的局部性原理，故不能提高Cache的命中率。

****

## 4.4 辅助存储器

****

### 4.4.1 概述

****

#### 辅助存储器的特点

****

**辅助存储器作为主存的后援设备又称为外部存储器，简称外存**，它与主存一起组成了存储器系统的主存——辅存层次。

* 辅存具有容量大、速度慢、价格低、可脱机保存信息等特点，属“非易失性”存储器。
* 主存具有速度快、成本高、容量小等特点，而且大多由半导体芯片构成，所存信息无法永久保存，属“易失性”存储器。

目前，广泛用于计算机系统的辅助存储器有硬磁盘、软磁盘、磁带、光盘等。前三种均属磁表面存储器。

****

#### 主要技术指标

****

* 记录密度：单位长度内所存储的二进制信息量。单位长度磁道能记录二进制信息的位数，称为位密度或线密度。
* 存储容量：外存所能存储的二进制信息总数量，一般以位或字节为单位。
* 平均寻址时间：取寻址时间的平均值，称为平均寻址时间。
* 数据传输率：单位时间内磁表面存储器向主机传送数据的位数或字节数，它与记录密度和记录介质的运动速度有关。
* 误码率：衡量磁表面存储器出错概率的参数，它等于从辅存读出时，出错信息位数和读出信息的总位数之比。

****

### 4.4.2 磁盘存储器

****

#### 硬磁盘存储器

****

**硬磁盘存储器类型**：

* 按磁头的工作方式可分为固定**磁头磁盘存储器**和**移动磁头磁盘存储器**；
* 按磁盘是否具有可换性又可分为**可换盘磁盘存储器**和**固定盘磁盘存储器**。

**硬磁盘存储器的结构**：

* 磁盘驱动器：主机外的一个独立装置，又称磁盘机，用于驱动磁盘。
* 磁盘控制器：是接收由主机发来的命令，将它转换成磁盘驱动器的控制命令，实现主机和驱动器之间的数据格式转换和数据传送。
* 盘片：存储信息的载体，一般为半导体盘。

****

#### 软磁盘存储器

****

软磁盘存储器与硬磁盘存储器的存储原理和记录方式是相同的，但在结构上有较大差别：

* 硬盘转速高，存取速度快；软盘转速低，存取速度慢。
* 硬盘有固定磁头、固定盘、盘组等结构；软盘都是活动头，可换盘片结构。
* 硬盘是靠浮动磁头读/写，磁头不接触盘片；软盘磁头直接接触盘片进行读/写。
* 硬盘系统及硬盘片价格比较贵，大部分盘片不能互换；软盘价格便宜，盘片保存方便、使用灵活、具有互换性。
* 硬盘对环境要求苛刻，要求采用超净措施；软盘对环境的要求不苛刻。

****

### 4.4.3 光盘存储器

****

光盘(Optical Disk)是利用光学方式进行读/写信息的圆盘。

如果光存储使用的介质是磁性材料，即利用激光在磁记录介质上存储信息，就称为磁光存储：

* 通常把采用非磁性介质进行光存储的技术称为第一代光存储技术，它不能把内容抹掉重写新内容。
* 磁光存储技术是在光存储技术基础上发展起来的，称为第二代光存储技术，主要特点是可擦除重写。

根据光存储性能和用途的不同，光盘存储器可分为三类：

* 只读型光盘(CD-ROM)：光盘内的数据和程序是由厂家事先写入的，使用时用户只能读出，不能修改或写入新的内容。
* 只写一次型光盘(WORM)：允许用户写入信息，写入后可多次读出，但只能写人一次，而且不能修改。
* 可擦写型光盘这种光盘类似磁盘，可以重复读/写。

****

# 5. 输入输出系统

****

## 5.1 输入输出系统概述

****

### 5.1.1 输入输出系统的发展概况

****

#### 早期阶段

****

早期的I/O设备种类较少，I/O设备与主存交换信息都必须通过CPU：

![](图片5\早期阶段.png)

* 每个I/O设备都必须配有一套独立的逻辑电路与CPU相连，**线路十分散乱、庞杂**。
* 输入输出过程是穿插在CPU执行程序过程之中进行的，**工作效率低**。
* 每个I/0设备的逻辑控制电路与CPU的控制器紧密构成一个不可分割的整体，**可扩展性低**。

****

#### 接口模块和DMA阶段

****

这个阶段I/O设备通过接口模块与主机连接，计算机系统采用了总线结构：

![](图片5\接口模块阶段.png)

* 数据经过接口既起到缓冲作用，又可完成串——并变换。
* 接口能满足中断请求处理的要求，使I/O设备与CPU可按并行方式工作，大大地提高了CPU的工作效率。
* 接口技术还可以使多台I/O设备分时占用总线，使多台I/O设备互相之间也可实现并行工作方式，有利于整机工作效率的提高。

为了进一步提高CPU的工作效率，又出现了直接存储器存取(Direct Memory Access,DMA)技术：

* I/O设备与主存之间有一条直接数据通路；
* I/O设备可以与主存直接交换信息，使CPU在I/O设备与主存交换信息时能继续完成自身的工作，故资源利用率得到了进一步提高。

****

#### 具有通道结构的阶段

****

![](图片5\通道结构阶段.png)

* 通道是用来负责管理I/O设备以及实现主存与I/O设备之间交换信息的部件。
* 通道有专用的通道指令，能独立地执行用通道指令所编写的输入输出程序，是从属于CPU的一个专用处理器。
* 依赖通道管理的I/O设备在与主机交换信息时，CPU不直接参与管理，故提高了CPU的资源利用率。

****

#### 具有I/O处理机的阶段

****

输入输出系统发展到第四阶段，出现了I/O处理机：

* I/O处理机又称为外围处理机(Peripheral Processor)；
* 它基本独立于主机工作，既可完成I/O通道要完成的I/O控制，又可完成码制变换、格式处理、数据块检错、纠错等操作。
* 具有I/O处理机的输入输出系统与CPU工作的并行性更高，这说明I/O系统对主机来说具有更大的独立性。

****

### 5.1.2 输入输出系统的组成

****

输入输出系统：

* I/O软件
* I/O硬件

****

#### I/O 软件

****

输入输出系统软件的主要任务如下：

* 将用户编制的程序（或数据）输入主机内。
* 将运算结果输送给用户。
* 实现输入输出系统与主机工作的协调等。

组成：

* I/O指令：机器指令的一类，其设备码相当于设备的地址，用于选择某台设备与主机交换信息。
* 通道指令：又称为通道控制字(Channel Control Word,CCW)，是通道自身的指令，用来执行I/O操作，如读、写、磁带走带及磁盘找道等。

****

#### I/O 硬件

****

![](图片5\IO硬件.png)

输入输出系统的硬件组成是多种多样的，在带有接口的I/O系统中，一般包括：

* 接口模块
* I/O设备两

如上图所示：

* 具有通道的I/O系统；
* 一个通道可以和一个以上的设备控制器相连，一个设备控制器又可以控制若干台同一类型的设备。

****

### 5.1.3 I/O 设备与主机的联系方式

****

I/O 设备与主机交换信息时，共有5种控制方式：

* 程序查询方式：程序查询方式是由CPU通过程序不断查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息。
* 程序中断方式：当I/O设备准备就绪并向 CPU发出中断请求后才予以响应。
* 直接存储器存取方式(DMA)：主存与I/O设备之间有一条数据通路，主存与I/0设备交换信息时，无须调用中断服务程序。
* I/O 通道方式；
* I/O处理机方式。

****

## 5.2 I/O 设备

****

### 5.2.1 I/O 设备概述

****

I/O设备大致可分为三类：

* 人机交互设备：·实现操作者与计算机之间互相交流信息的设备。
* 计算机信息的存储设备：系统软件和各种计算机的有用信息，其信息量极大，需存储保留起来。
* 机——机通信设备：实现一台计算机与其他计算机或与其他系统之间完成通信任务的设备。

![](图片5\IO用途.png)

****

### 5.2.2 输入设备

****

输入设备完成输入程序、数据和操作命令等功能：

* 键盘：通过键盘上的各个键，按某种规范向主机输入各种信息，如汉字、外文、数字等。
* 鼠标：手持式的定位设备，由于它拖着一根长线与接口相连，外形有点像老鼠，故取名为鼠标。
* 触摸屏：是一种对物体的接触或靠近能产生反应的定位设备。按原理的不同，触摸屏大致可分为5类：电阻式、电容式、表面超声波式、扫描红外线式和压感式。
* 其他输人设备：
  * 光笔：外形与钢笔相似，头部装有一个透镜系统，能把进入的光会聚成一个光点。光笔的后端用导线连到计算机输入电路上。
  * 画笔与图形板：画笔(Stylus)同样为笔状，但必须配合图形板(Tablet)使用。
  * 图像输入设备：最直接的图像输入设备是摄像机(Camera)，它能被拍摄物经数字量化后变成数字图像存入磁带或磁盘。

****

###  5.2.3 输出设备

****

#### 显示设备

****

* 字符显示器：
  * 显示存储器（刷新存储器）VRAM：显示存储器存放欲显示字符的ASCII码，其容量与显示屏能显示的字符个数有关。
  * 字符发生器：将每个ASCII字符码转变为一组5×7或7×9的光点矩阵信息。
  * CRT控制器：可接收来自CPU的数据和控制信号，并给出访问显示存储器的地址和访问字符发生器的光栅地址，还能给出CRT所需的水平同步和垂直同步信号。
* 图形显示器：图形显示器是用点、线（直线和曲线）、面（平面和曲面）组合成平面或立体图形的显示设备；
* 图像显示器：图形显示器所显示的图形是由计算机用一定的算法形成的点、线、面、阴影等，来自主观世界，故又称为主观图像或计算机图像。
* IBM PC系列微型计算机的显示标准：
  * MDA(Monochrome Display Adapter)标准： MDA是单色字符显示标准，采用9×14点阵的字符窗口，满屏显示80列、25行字符，对应分辨率为720×350像素。MDA不能兼容图形显示。
  * CGA(Color Graphics Adapter)标准： CGA是彩色图形/字符显示标准，可兼容字符和图形两种显示方式。在字符方式下，字符窗口为8×8点阵，故字符质量不如MDA,但字符的背景可以选择颜色。
  * EGA(Enhanced Graphics Adapter)标准： EGA标准集中了MDA和CGA两个显示标准的优点，并有所增强。其字符窗口为8×14点阵，字符显示质量优于CGA而接近MDA。
  * VGA(Video Graphics Array)标准： VGA标准在字符方式下，字符窗口为9×16点阵，在图形方式下分辨率为640×480像素、 16种颜色，或320×200像素、256种颜色，还有720×400像素的文本模式。

****

#### 打印设备

****

* 点阵针式打印机：结构简单、体积小、重量轻、价格低、字符种类不受限制、较易实现汉字打印，还可打印图形和图像。
* 激光打印机：采用了激光技术和照相技术，印字质量好，应用广泛。
* 喷墨打印机：是串行非击打式打印机，印字原理是将墨水喷射到普通打印纸上。若采用红、绿、蓝三色喷墨头，便可实现彩色打印。

****

## 5.3 I/O 接口

****

### 5.3.1 I/O 接口概述

****

接口可以看做是两个系统或两个部件之间的交接部分，它**既可以是两种硬设备之间的连接电路，也可以是两个软件之间的共同逻辑边界。**

设置接口理由如下：

* 一台机器通常配有多台I/O设备，它们各自有英设备号（地址），通过接口可实现I/0设备的选择。
* I/O设备种类繁多，速度不一，与CPU速度相差可能很大，通过接口可实现数据缓冲.
* 有些I/O设备可能串行传送数据，而CPU一般为并行传送，通过接口可实现数据串——并格式的转换。
* I/O设备的输人输出电平可能与CPU的输入输出电平不同，通过接口可实现电平转换。
* CPU启动I/O设备工作，要向I/O设备发各种控制信号，通过接口可传送控制命令。
* I/O设备需将其工作状态及时向CPU报告，通过接口可监视设备的工作状态，并可保存状态信息，供CPU查询。

****

### 5.3.2 接口的功能和组成

****

![](图片5\IO总线.png)

如上图所示为总线结构的计算机，每一台I/O设备都是通过I/O接口挂到系统总线上的。图中的I/O总线包括数据线、设备选择线、命令线和状态线。

根据上述设置接口的理由，可归纳出接口通常应具有以下几个功能以及相应的硬件配置：

* 选址功能：当设备选择线上的设备码与本设备码相符时，应发出设备选中信号SEL；
* 传送命令的功能：通常在I/O接口中设有存放命令的命令寄存器以及命令译码器，来对CPU的命令进行响应。
* 传送数据的功能：接口中通常设有数据缓冲寄存器(Data Buffer Register,DBR)，它用来暂存I/O设备与主机准备交换的信息，与I/O总线中的数据线是相连的。
* 反映I/0设备工作状态的功能：为了使CPU能及时了解各I/O设备的工作状态，接口内必须设置一些反映设备工作状态的触发器。

****

### 5.3.3 接口类型

****

![](图片5\IO接口基本组成.png)

* 按数据传送方式分类：
  * 并行接口：将一个字节（或一个字）的所有位同时传送；
  * 串行接口：在设备与接口间一位一位传送，由于接口与主机之间是按字节或字并行传送，因此对串行接口而言，其内部还必须设有串——并转换装置。
* 按功能选择的灵活性分类：
  * 可编程接口：其功能及操作方式可用程序来改变或选择；
  * 不可编程接口：不能由程序来改变其功能，但可通过硬连线逻辑来实现不同的功能。
* 按通用性分类：
  * 通用接口：可供多种I/O设备使用；
  * 专用接口：为某类外设或某种用途专门设计的。
* 按数据传送的控制方式分类：
  * 程序型接口：用于连接速度较慢的I/O设备，如显示终端、键盘、打印机等；
  * DMA型接口：用于连接高速I/0设备，如磁盘、磁带等。

****

## 5.4 程序查询方式

****

### 5.4.1 程序查询流程

****

#### 单 IO 设备

****

![](图片5\单IO设备查询.png)

****

#### 多 IO 设备

****

![](图片5\多IO设备查询.png)

****

### 5.4.2 程序查询方式的接口电路

****

![](图片5\查询接口电路.png)

以输入设备为例，该接口的工作过程如下：

* 当CPU通过I/O指令启动输入设备时，指令的设备码字段通过地址线送至设备选择电路。
* 若该接口的设备码与地址线上的代码吻合，其输出SEL有效。
* I/O指令的启动命令经过“与非”门将工作触发器B置“1”，将完成触发器D置“0”。
* 由B触发器启动设备工作。
* 输入设备将数据送至数据缓冲寄存器。
* 由设备发设备工作结束信号，将D置“1”，B置“0”，表示外设准备就绪。
* D触发器以“准备就绪”状态通知CPU,表示“数据缓冲满”。
* CPU执行输入指令，将数据缓冲寄存器中的数据送至CPU的通用寄存器，再存人主存相关单元。

****

## 5.5 程序中断方式

****

### 5.5.1 I/O中断的概念

****

**中断**：计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序。

****

### 5.5.2 I/O 中断的产生

****

在I/O设备与主机交换信息时，由于设备本身机电特性的影响，其工作速度较低，与CPU无法匹配，因此，CPU启动设备后，往往需要等待一段时间才能实现主机与I/O设备之间的信息交换。

如果在设备准备的同时，CPU不作无谓的等待，而继续执行现行程序，**只有当I/O设备准备就绪向CPU提出请求后，再暂时中断CPU现行程序转入I/O服务程序，这便产生了I/O中断。**

****

### 5.5.3 程序中断方式的接口电路

****

为处理I/O中断，在I/O接口电路中必须配置相关的硬件线路：

* 中断请求触发器和中断屏蔽触发器：每台外部设备都必须配置一个中断请求触发器INTR,当其为“1”时，表示该设备向CPU提出中断请求。但是设备欲提出中断请求时，其设备本身必须准备就绪，即接口内的完成触发器D的状态必须为“1”。
* 排队器：当多个中断源同时向CPU提出请求时，CPU只能按中断源的不同性质对其排队，给予不同等级的优先权，并按优先等级的高低予以响应。
* 中断向量地址形成部件（设备编码器）：CPU一旦响应了I/O中断，就要暂停现行程序，转去执行该设备的中断服务程序。不同的设备有不同的中断服务程序，每个服务程序都有一个入口地址，CPU必须找到这个入口地址。

**注意**：

* 就 I/O 中断而言，速度越高的I/O设备，优先级越高，因为若CPU不及时响应高速I/O的请求，其信息可能会立即丢失。

****

### 5.5.4 I/O中断处理过程

****

#### CPU响应中断的条件和时间

****

CPU响应I/O设备提出中断请求的条件是必须满足CPU中的允许中断触发器EINT为“1”。该触发器可用开中断指令置位（称为开中断）；也可用关中断指令或硬件自动使其复位（称为关中断)。

**CPU响应中断的时间一定是在每条指令执行阶段的结束时刻。**

![](图片5\中断接口电路组成.png)

****

#### I/O 中断处理过程

****

中断处理过程可以分为五个阶段：

* 中断请求
* 中断判优
* 中断响应
* 中断服务
* 中断返回

具体地：

![](图片5\中断处理过程.png)

* 由CPU发启动I/O设备命令，将接口中的B置“1”，D置“0”。
* 接口启动输入设备开始工作。
* 输入设备将数据送入数据缓冲寄存器。
* 输入设备向接口发出“设备工作结束”信号，将D置“1”，B置“0”，标志设备准备就绪。
* 当设备准备就绪(D=1),且本设备未被屏蔽(MASK=0)时，在指令执行阶段的结束时刻，由CPU发出中断查询信号。
* 设备中断请求触发器INTR被置“1”，**标志设备向CPU提出中断请求**。与此同时，**INTR送至排队器，进行中断判优**。
* 若CPU允许中断(EINT=1),设备又被排队选中，即**进入中断响应阶段**，由中断响应信号 INTA将排队器输出送至编码器形成向量地址。
* 向量地址送至PC，作为下一条指令的地址。
* 由于向量地址中存放的是一条无条件转移指令，故这条指令执行结束后，即无条件转至该设备的服务程序入口地址，开始执行中断服务程序，**进人中断服务阶段**，通过输入指令将数据缓冲寄存器的输入数据送至CPU的通用寄存器，再存入主存相关单元。
* 中断服务程序的最后一条指令是中断返回指令，当其执行结束时，即**中断返回**至原程序的断点处。
* 至此，一个完整的程序中断处理过程即告结束。

****

## 5.6 DMA 方式

****

### 5.6.1 DMA 方式的特点

****

![](图片5\DMA方式数据传送.png)

由图中可见，由于**主存和DMA接口之间有一条数据通路**，因此主存和设备交换信息时，不通过CPU，也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复现场，因此工作速度比程序中断方式的工作速度高。

在DMA方式中，由于DMA接口与CPU共享主存，这就有可能出现两者争用主存的冲突。为了有效地分时使用主存，通常DMA与主存交换数据时采用如下三种方法：

* 停止CPU访问主存：
  * 方式：当外设要求传送一批数据时，由DMA接口向CPU发一个停止信号，要求CPU放弃地址线数据线和有关控制线的使用权。DMA接口获得总线控制权后，开始进行数据传送，在数据传送结束后，DMA接口通知CPU可以使用主存，并把总线控制权交回给CPU。
  * 优点：控制简单，适用于数据传输率很高的I/O设备实现成组数据的传送。
  * 缺点：DMA接口在访问主存时，CPU基本上处于不工作状态或保持原状态。
* 周期挪用（或周期窃取）：
  * 方式：在这种方法中，每当I/O设备发出DMA请求时，I/O设备便挪用或窃取总线占用权一个或几个主存周期，而DMA不请求时，CPU仍继续访问主存。
  * 优点：这种方式既实现了I/O传送，又较好地发挥了主存与CPU的效率，是一种广泛采用的方法。
  * 缺点：比较适合于I/O设备的读/写周期大于主存周期的情况，其他情况不推荐使用。
* DMA与CPU交替访问：
  * 方式：不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和C2分别控制的。 CPU与DMA接口各自有独立的访存地址寄存器、数据寄存器和读/写信号。
  * 优点：CPU既不停止主程序的运行也不进入等待状态，即完成了 DMA的数据传送，效率较高。
  * 缺点：相应的硬件逻辑复杂。

****

### 5.6.2 DMA接口的功能和组成

****

#### DMA接口的功能

****

利用DMA方式传送数据时，DMA接口应具有如下几个功能：

* 向CPU申请DMA传送。
* 在CPU允许DMA工作时，处理总线控制权的转交，避免因进入DMA工作而影响CPU正常活动或引起总线竞争。
* 在DMA期间管理系统总线，控制数据传送。
* 确定数据传送的起始地址和数据长度，修正数据传送过程中的数据地址和数据长度。
* 在数据块传送结束时，给出DMA操作完成的信号。

****

#### DMA接口基本组成

****

![](图片5\DMA接口组成.png)

* 主存地址寄存器(AR) ：用于存放主存中需要交换数据的地址。
* 字计数器(WC) ：用于记录传送数据的总字数，通常以交换字数的补码值预置。
* 数据缓冲寄存器(BR) ：用于暂存每次传送的数据。
* DMA控制逻辑： 负责管理DMA的传送过程，由控制电路、时序电路及命令状态控制寄存器等组成。
* 中断机构：当字计数器溢出（全“0”）时，表示一批数据交换完华，由“溢出信号”通过中断机构向CPU提出中断请求，请求CPU作DMA操作的后处理。
* 设备地址寄存器(DAR) ：存放I/O设备的设备码或表示设备信息存储区的寻址信息，如磁盘数据所在的区号盘面号和柱面号。

****

### 5.6.3 DMA的工作过程

****

DMA的数据传送过程分为三个阶段：

* 预处理
* 数据传送
* 后处理

****

#### 预处理

****

* 给DMA控制逻辑指明数据传送方向是输入（写主存）还是输出（读主存）。
* 向DMA设备地址寄存器送入设备号，并启动设备。
* 向DMA主存地址寄存器送入交换数据的主存起始地址。
* 对字计数器赋予交换数据的个数。

****

#### 数据传送

****

![](图片5\DMA数据传送.png)

****

#### 后处理

****

当DMA的中断请求得到响应后，CPU停止原程序的执行，转去执行中断服务程序，执行DMA的结束工作：

* 校验送入主存的数据是否正确；
* 决定是否继续用DMA传送其他数据块，若继续传送，则又要对DMA接口进行初始化，若不需要传送，则停止外设；
* 测试在传送过程中是否发生错误，若出错，则转错误诊断及处理错误程序。

****

### 5.6.4 DMA接口的类型

****

#### 选择型DMA接口

****

![](图片5\选择型DMA接口.png)

**特点**：

* 在物理上可连接多个设备，在逻辑上只允许连接一个设备，即在某一段时间内，DMA接口只能为一个设备服务；
* 关键是在预处理时将所选设备的设备号送入设备地址寄存器。

****

#### 多路型DMA接口

****

![](图片5\多路型DMA接口.png)

**特点**：

* 多路型DMA接口不仅在物理上可以连接多个设备，而且在逻辑上也允许多个设备同时工作，各个设备采用字节交叉的方式通过DMA接口进行数据传送。
* 这类接口特别适合于同时为多个数据传输率不十分高的设备服务。

****

# 6. 计算机的运算方法

****

## 6.1 数字在计算机中的表示

****

### 6.1.0 基本概念

****

#### 单位概念

****

**位**（bit）：计算机中最小的数字单位，是“二进制数字”（binary digit）的缩写，它只能取 $0$ 或 $1$ 两个值，因此bit被称作“二进制位”。

**字节**（byte）：$8$ 个bit组成 $1$ 个字节（byte），通常也是计算机中最常见的数据大小单位，用于表示 $8$ 个二进制位的数字或字符。

**在计算机中，一个bit指的就是一个二进制位，即最小的数字单位。**

****

#### 二进制表示

****

例如：

* 在计算机中，$7$ 被表示为 $0000,0111$。其中，每四位加入 `,` 便于区分位数。

具体地：

* $0000,0111$ 表示的二进制数字是 $00000111$。
* 其中，前四位 $0000$ 表示十进制下的 $0$，后四位 $0111$ 表示十进制下的 $7$。
* $0\times2^7+0\times2^6+0\times2^5+0\times2^4+0\times2^3+1\times2^2+1\times2^1+1\times2^0=7$
* 该表示法将数字 $7$ 以二进制形式表示，并在前面补上了 $0$，使其达到了 $8$ 比特位（bits）的宽度，常常使用这种形式来表示计算机存储的二进制数。

按照上述过程，理论上一个字节（8个bit位）最大表示的数值范围为：

*  $0000,0000(0) \sim 1111,1111(255)$。

****

### 6.1.1 原码、反码、补码、移码

****

由于现实计算中不仅存在正数，还存在负数，因此按照 `6.1.0` 节中将一个字节中所有位都用来表示数是不合理的。

因此，在一些语言中区分了**有符号数**和**无符号数**，像上节中表示的是无符号数的表示方法。

****

#### 原码表示法

****

在使用原码表示法时，**二进制数的最高位表示符号位**，$0$ 表示正数，$1$ 表示负数。

以使用 $8$ 位二进制原码为例，表示 $-7$ 的二进制原码的步骤如下：

* 将 $7$ 的二进制表示转换为 $8$ 位二进制数的原码： $0000,0111$。
* 将该二进制数的符号位取反，即将第一位由“0”变为“1”，得到：$1000,0111$。

因此，在 $8$ 位二进制原码表示法中，$-7$ 的二进制原码为 $1000,0111$。

按照上述过程，在原码表示下，理论上一个字节（8个bit位）最大表示的数值范围为：

* $11111,1111(-127) \sim 0111,1111(127)$。

需要注意，这种方式的缺点是正数和负数的加减法需要额外处理符号位，较为复杂。

例如计算：$-1 + 1 = 1000,0001 + 0000,0001 = 1000,0010(-2)$ 

怎么会是呢？？？显然是不对滴，因此我们又引入了反码。

****

#### 反码表示法

****

反码是一种用于计算机中表示负数的二进制数表示法。在反码中：

* 正数的反码与其原码相同；
* 而负数则取其对应正数的原码每一位取反（0变为1，1变为0）得到。
* 反码最高位仍作为符号位，0表示正数，1表示负数。

以使用 $8$ 位二进制原码为例，表示 $-7$ 的二进制反码的步骤如下：

* 将 $7$ 的二进制表示转换为 $8$ 位二进制数的原码： $0000,0111$。
* 将该二进制数的每一位取反，即将所有的位由“0”变为“1”，得到：$1111,1000$。

因此，在 $8$ 位二进制反码表示法中，$-7$ 的二进制反码为 $1111,1000$。

现在计算：$-1 + 1 = 1111,1110 + 0000,0001 = 1111,1111(反码)$

**注意**：反码直接计算的结果需要取反才能得到原码，因此对 $1111,1111$ 的非符号位全部取反得到 $1000,0000(-0)$。

~~显然是对的吧~~，数值是对了，但是出现了“+0”和“-0”的问题，依然不合理，因此我们最终引入了补码。

****

#### 补码表示法

****

补码是一种计算机中表示有符号整数的二进制数表示法，也是一种将负数转化为正数的方法。在补码中：

* 正数的补码与其原码相同；
* 而负数则为其二进制反码加一。

以使用 $8$ 位二进制原码为例，表示 $-7$ 的二进制反码的步骤如下：

* 将 $7$ 的二进制表示转换为 $8$ 位二进制数的原码： $0000,0111$。
* 将每一位取反得到反码：$1111,1000$，然后末位 $+1$ 得到：$1111,1001$。

因此，在 $8$ 位二进制反码表示法中，$-7$ 的二进制补码为 $1111,1001$，由于 $-6$ 的二进制补码为 $1111,1010$，故我们将原本为 $1111,1000$ 表示为最小值 $-8$。

按照上述过程，在补码表示下，理论上一个字节（8个bit位）最大表示的数值范围为：

* $1000,0000(-128) \sim 0111,1111(127)$

现在计算：$-1 + 1 = 1111,1111 + 0000,0001 = 1,0000,0000$，其中多出来的一位 $1$ 由于超过了补码的表示范围，故造成了溢出，最终的计算结果为 $0000,0000(0)$。

由此，我们通过补码可以将两个数的减法运算变为加法运算，但是由于符号位的存在，补码很难直接判断真值大小，因此引入移码的概念。

****

#### 移码表示法

****

移码是一种为了方便计算二进制浮点数而设计的表示方法：

* 将每个真值加上一个偏置值，再进行存储；
* $[ x ]_移 = 2^n + x (2^n > x \ge -2^n)$

举例：

例如 $x$ 的真值为 $10100$：

$x = 10100,[ x ]_移 = 2^5+10100 = 1,10100(用,分割符号位)$

$-x = -10100,[ -x ]_移 = 2^5-10100 = 0,01100$

当 $x = 0$ 时： 

$[ +0 ]_ 移 = [ -0 ]_ 移$

**注意**：

* 移码与补码只差一个符号位，符号位取反两者就能相互转换。

**证明**：

* 正数：$[ x ]_ 移 = 2^n + x$，相当于在第 $n$ 位 $+1$，即在符号位取反。
* 负数：$[ x ]_ 补 = 2^{n+1}+x = (2^n+x) + 2^n = [ x ]_ 移 + 2^n$，也相当于符号位取反。

****

### 6.1.2 IEEE 754 标准

****

![](图片6\IEEE754标准.png)

根据国际标准 IEEE 754，任意一个二进制浮点数 $V$ 可以表示成下面的形式：
$$
V = (-1)^S \times M \times 2^E
$$

* $(-1)^S$ 表示符号位，当 $S=0$，$V$ 为正数；当 $S=1$，$V$ 为负数。
* $M$ 表示有效数字，大于等于 $1$，小于 $2$，但整数部分的 $1$ 不变，因此可以省略。（例如尾数为 $1111010$，那么 $M$ 实际上就是$1.111010$，尾数首位必须是 $1$，$1$ 后面紧跟小数点，如果出现 $0001111$ 这样的情况，去掉前面的 $0$，移动 $1$ 到首位，随着时间的发展，IEEE 754标准默认第一位为 $1$，故为了能够存放更多数据，就舍去了第一位，比如保存 $1.0101$ 的时候， 只保存 $0101$，这样能够多存储一位数据）
* $2^E$ 表示指数位。（用于移动小数点，所以说才称为浮点型）

比如， 对于十进制的 $5.25$ 对应的二进制为：$101.01$，相当于：$1.0101 \times 2^2$。所以，$S$ 为 $0$，$M$ 为 $1.0101$，$E$ 为 $2$。因此，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码，所以浮点类型的大致取值范围：

* 单精度：$±3.40282347 \times 10^{38}$
* 双精度：$±1.79769313486231570 \times 10^{308}$

****

## 6.2 数的定点表示和浮点表示

****

上述 `6.1.2` 讲解了当前通用的 `IEEE 754` 标准，为了深入理解小数在计算机中的表示，下面介绍小数的表示法。

****

### 6.2.1 定点表示

****

![](图片6\定点表示法.png)

**特点**：

* 当小数点位于数符和第一数值位之间时，机器内的数为纯小数；
* 当小数点位于数值位之后时，机器内的数为纯整数。

**采用定点数的机器称为定点机**。数值部分的位数决定了定点机中数的表示范围。

**注意**：

在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则会产生“溢出”。

****

### 6.2.2 浮点表示

****

![](图片6\浮点表示法.png)



**特点**：

* 浮点数由阶码j和尾数S两部分组成。
* 阶码是整数，阶符和阶码的位数m合起来反映浮点数的表示范围及小数点的实际位置；
* 尾数是小数，其位数反映了浮点数的精度；尾数的符号 $S_f$。

****

#### 浮点数范围

****

![](图片6\浮点表示范围.png)

以通式 $N = S \times r^j$ 为例，设浮点数阶码的数值位取 $m$ 位，尾数的数值位取 $n$ 位，当浮点数为非规格化数时，它在数轴上的表示范围如图所示。

****

#### 浮点数的规格化

****

**规格化形式：**

- 基数 r = 2 ，尾数最高位为 1
- 基数 r = 4 ，尾数最高 2 位不全为 0
- 基数 r = 8 ，尾数最高 3 位不全为 0

基数不同，浮点数的规格化形式不同。

**规格化方式：**

- r = 2 左规 尾数左移 1 位，阶码减 1
     右规 尾数右移 1 位，阶码加 1
- r = 4 左规 尾数左移 2 位，阶码减 1
     右规 尾数右移 2 位，阶码加 1
- r = 8 左规 尾数左移 3 位，阶码减 1
     右规 尾数右移 3 位，阶码加 1

基数 r 越大，可表示的浮点数的范围越大，基数 r 越大，浮点数的精度降低。

****

## 6.3 定点运算

****

### 6.3.1 移位运算

****

#### 算术移位规侧

****

**有符号数的移位称为算术移位**，其移位规则如下：

![](L:\02 学习笔记\计算机组成原理\图片6\算术移位.png)

当 $A = 26$ 时：

![](L:\02 学习笔记\计算机组成原理\图片6\A26.png)

当 $A = -26$ 时：

![](L:\02 学习笔记\计算机组成原理\图片6\A-26.png)

****

#### 逻辑移位规则

****

**无符号数的移位称为逻辑移位**，其规则等同于正数的算术移位规则。

****

### 6.3.2加法与减法运算

****

#### 基本运算公式

****

**加法运算**：

![](L:\02 学习笔记\计算机组成原理\图片6\补码加法.png)

**减法运算**：

![](L:\02 学习笔记\计算机组成原理\图片6\补码减法.png)

****

#### 溢出判断

****

**补码运算，符号位改变即为溢出**。

例如：

以使用 $8$ 位二进制原码为例，计算 $125 + 7$ 的过程如下：

$125$ 的二进制补码为：$0111,1101$，$7$ 的二进制补码为 $0000,0111$。

```
  0111 1101
+ 0000 0111
-----------
  1000 0100
```

符号位发生改变，说明发生了溢出。

**注意**：只有参与运算的数符号相同时才有可能发生溢出。

****

### 6.3.3 乘法运算

****

分析乘法过程：

```
            1 1 1 1
×           1 1 0 1
———————————————————
            1 1 1 1
          0 0 0 0
        1 1 1 1
+     1 1 1 1
———————————————————
    1 1 0 0 0 0 1 1
```







# 7. 别急

****































****

# 8. 别急

****





















****

# 9. 别急

****





















****

# 10. 别急

****









